commit f317684
Merge: c339343 0985ae7
Author: Sage Weil <sage@inktank.com>
Date:   Tue Jun 24 02:09:49 2014

    Merge pull request #1979 from ceph/wip-backfill-priority
    
    osd: improve backfill prioritization
    
    Reviewed-by: Samuel Just <sam.just@inktank.com>

--- a/src/common/AsyncReserver.h
+++ b/src/common/AsyncReserver.h
@@ -33,6 +33,7 @@
 class AsyncReserver {
   Finisher *f;
   unsigned max_allowed;
+  unsigned min_priority;
   Mutex lock;
 
   map<unsigned, list<pair<T, Context*> > > queues;
@@ -42,7 +43,9 @@
   void do_queues() {
     typename map<unsigned, list<pair<T, Context*> > >::reverse_iterator it;
     for (it = queues.rbegin();
-         it != queues.rend() && in_progress.size() < max_allowed;
+         it != queues.rend() &&
+	   in_progress.size() < max_allowed &&
+	   it->first >= min_priority;
          ++it) {
       while (in_progress.size() < max_allowed &&
              !it->second.empty()) {
@@ -57,8 +60,12 @@
 public:
   AsyncReserver(
     Finisher *f,
-    unsigned max_allowed)
-    : f(f), max_allowed(max_allowed), lock("AsyncReserver::lock") {}
+    unsigned max_allowed,
+    unsigned min_priority = 0)
+    : f(f),
+      max_allowed(max_allowed),
+      min_priority(min_priority),
+      lock("AsyncReserver::lock") {}
 
   void set_max(unsigned max) {
     Mutex::Locker l(lock);
@@ -66,6 +73,12 @@
     do_queues();
   }
 
+  void set_min_priority(unsigned min) {
+    Mutex::Locker l(lock);
+    min_priority = min;
+    do_queues();
+  }
+
   /**
    * Requests a reservation
    *
--- a/src/common/config_opts.h
+++ b/src/common/config_opts.h
@@ -391,6 +391,9 @@
 // Maximum number of backfills to or from a single osd
 OPTION(osd_max_backfills, OPT_U64, 10)
 
+// Minimum recovery priority (255 = max, smaller = lower)
+OPTION(osd_min_recovery_priority, OPT_INT, 0)
+
 // Refuse backfills when OSD full ratio is above this value
 OPTION(osd_backfill_full_ratio, OPT_FLOAT, 0.85)
 
--- a/src/messages/MBackfillReserve.h
+++ b/src/messages/MBackfillReserve.h
@@ -28,8 +28,8 @@
     GRANT = 1,
     REJECT = 2,
   };
-  int type;
-  unsigned priority;
+  uint32_t type;
+  uint32_t priority;
 
   MBackfillReserve()
     : Message(MSG_OSD_BACKFILL_RESERVE, HEAD_VERSION, COMPAT_VERSION),
--- a/src/osd/OSD.cc
+++ b/src/osd/OSD.cc
@@ -219,8 +219,10 @@
   last_tid(0),
   tid_lock("OSDService::tid_lock"),
   reserver_finisher(cct),
-  local_reserver(&reserver_finisher, cct->_conf->osd_max_backfills),
-  remote_reserver(&reserver_finisher, cct->_conf->osd_max_backfills),
+  local_reserver(&reserver_finisher, cct->_conf->osd_max_backfills,
+		 cct->_conf->osd_min_recovery_priority),
+  remote_reserver(&reserver_finisher, cct->_conf->osd_max_backfills,
+		  cct->_conf->osd_min_recovery_priority),
   pg_temp_lock("OSDService::pg_temp_lock"),
   map_cache_lock("OSDService::map_lock"),
   map_cache(cct->_conf->osd_map_cache_size),
@@ -7929,6 +7931,7 @@
 {
   static const char* KEYS[] = {
     "osd_max_backfills",
+    "osd_min_recovery_priority",
     "osd_op_complaint_time", "osd_op_log_threshold",
     "osd_op_history_size", "osd_op_history_duration",
     "osd_map_cache_size",
@@ -7948,6 +7951,10 @@
     service.local_reserver.set_max(cct->_conf->osd_max_backfills);
     service.remote_reserver.set_max(cct->_conf->osd_max_backfills);
   }
+  if (changed.count("osd_min_recovery_priority")) {
+    service.local_reserver.set_min_priority(cct->_conf->osd_min_recovery_priority);
+    service.remote_reserver.set_min_priority(cct->_conf->osd_min_recovery_priority);
+  }
   if (changed.count("osd_op_complaint_time") ||
       changed.count("osd_op_log_threshold")) {
     op_tracker.set_complaint_and_threshold(cct->_conf->osd_op_complaint_time,
--- a/src/osd/OSD.h
+++ b/src/osd/OSD.h
@@ -630,11 +630,6 @@
   }
 
   // -- backfill_reservation --
-  enum {
-    BACKFILL_LOW = 0,   // backfill non-degraded PGs
-    BACKFILL_HIGH = 1,	// backfill degraded PGs
-    RECOVERY = AsyncReserver<spg_t>::MAX_PRIORITY  // log based recovery
-  };
   Finisher reserver_finisher;
   AsyncReserver<spg_t> local_reserver;
   AsyncReserver<spg_t> remote_reserver;
--- a/src/osd/PG.cc
+++ b/src/osd/PG.cc
@@ -1890,6 +1890,26 @@
   dirty_info = true;
 }
 
+unsigned PG::get_recovery_priority()
+{
+  // a higher value -> a higher priority
+  return OSD_RECOVERY_PRIORITY_MAX;
+}
+
+unsigned PG::get_backfill_priority()
+{
+  // a higher value -> a higher priority
+
+  // degraded: 200 + num missing replicas
+  if (is_degraded()) {
+    assert(pool.info.size > acting.size());
+    return 200 + (pool.info.size - acting.size());
+  }
+
+  // baseline
+  return 1;
+}
+
 void PG::finish_recovery(list<Context*>& tfin)
 {
   dout(10) << "finish_recovery" << dendl;
@@ -5853,13 +5873,12 @@
       backfill_osd_it->osd, pg->get_osdmap()->get_epoch());
     if (con) {
       if (con->has_feature(CEPH_FEATURE_BACKFILL_RESERVATION)) {
-        unsigned priority = pg->is_degraded() ? OSDService::BACKFILL_HIGH
-	  : OSDService::BACKFILL_LOW;
         pg->osd->send_message_osd_cluster(
           new MBackfillReserve(
 	  MBackfillReserve::REQUEST,
 	  spg_t(pg->info.pgid.pgid, backfill_osd_it->shard),
-	  pg->get_osdmap()->get_epoch(), priority),
+	  pg->get_osdmap()->get_epoch(),
+	  pg->get_backfill_priority()),
 	con.get());
       } else {
         post_event(RemoteBackfillReserved());
@@ -5928,8 +5947,8 @@
     pg->info.pgid,
     new QueuePeeringEvt<LocalBackfillReserved>(
       pg, pg->get_osdmap()->get_epoch(),
-      LocalBackfillReserved()), pg->is_degraded() ? OSDService::BACKFILL_HIGH
-	 : OSDService::BACKFILL_LOW);
+      LocalBackfillReserved()),
+    pg->get_backfill_priority());
 }
 
 void PG::RecoveryState::WaitLocalBackfillReserved::exit()
@@ -5996,7 +6015,8 @@
     pg->info.pgid,
     new QueuePeeringEvt<RemoteRecoveryReserved>(
       pg, pg->get_osdmap()->get_epoch(),
-      RemoteRecoveryReserved()), OSDService::RECOVERY);
+      RemoteRecoveryReserved()),
+    pg->get_recovery_priority());
 }
 
 boost::statechart::result
@@ -6156,7 +6176,8 @@
     pg->info.pgid,
     new QueuePeeringEvt<LocalRecoveryReserved>(
       pg, pg->get_osdmap()->get_epoch(),
-      LocalRecoveryReserved()), OSDService::RECOVERY);
+      LocalRecoveryReserved()),
+    pg->get_recovery_priority());
 }
 
 void PG::RecoveryState::WaitLocalRecoveryReserved::exit()
--- a/src/osd/PG.h
+++ b/src/osd/PG.h
@@ -777,6 +777,11 @@
   bool needs_recovery() const;
   bool needs_backfill() const;
 
+  /// get log recovery reservation priority
+  unsigned get_recovery_priority();
+  /// get backfill reservation priority
+  unsigned get_backfill_priority();
+
   void mark_clean();  ///< mark an active pg clean
 
   bool _calc_past_interval_range(epoch_t *start, epoch_t *end, epoch_t oldest_map);
--- a/src/osd/osd_types.h
+++ b/src/osd/osd_types.h
@@ -56,6 +56,10 @@
 #define CEPH_OSD_FEATURE_INCOMPAT_SHARDS CompatSet::Feature(11, "sharded objects")
 
 
+/// max recovery priority for MBackfillReserve
+#define OSD_RECOVERY_PRIORITY_MAX 255u
+
+
 typedef hobject_t collection_list_handle_t;
 
 typedef uint8_t shard_id_t;
