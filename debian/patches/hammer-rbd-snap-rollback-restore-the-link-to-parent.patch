From: Alexey Sheplyakov <asheplyakov@mirantis.com>
Date: Mon, 11 Apr 2016 14:16:48 +0300
Subject: hammer: rbd snap rollback: restore the link to parent

So snapshot, flatten, rollback of a cloned image does not loose any data

Fixes: #14512
Signed-off-by: Alexey Sheplyakov <asheplyakov@mirantis.com>
---
 src/librbd/internal.cc    | 53 +++++++++++++++++++++++++++++++++++++++++++++++
 src/librbd/parent_types.h | 10 +++++++--
 2 files changed, 61 insertions(+), 2 deletions(-)

diff --git a/src/librbd/internal.cc b/src/librbd/internal.cc
index 8c6e1b8..f4b110e 100644
--- a/src/librbd/internal.cc
+++ b/src/librbd/internal.cc
@@ -413,6 +413,48 @@ int validate_pool(IoCtx &io_ctx, CephContext *cct) {
     rados_completion->release();
   }
 
+  int rollback_parent(ImageCtx *ictx, uint64_t snap_id)
+  {
+    assert(ictx);
+    assert(ictx->parent_lock.is_locked());
+    assert(ictx->snap_lock.is_locked());
+
+    CephContext *cct = ictx->cct;
+    int r = 0;
+    std::map<librados::snap_t, SnapInfo>::const_iterator it = ictx->snap_info.find(snap_id);
+    if (it == ictx->snap_info.end()) {
+      ldout(cct, 10) << __func__ << ": no such snapshot: " << snap_id << dendl;
+      return -ENOENT;
+    }
+    const SnapInfo& snap_info(it->second);
+    if (ictx->parent_md == snap_info.parent) {
+      ldout(cct, 20) << __func__ << ": nop: head and snapshot have the same parent" << dendl;
+      return 0;
+    }
+    if (ictx->parent_md.spec.pool_id != -1) {
+       // remove the old parent link first, otherwise cls_client::set_parent
+       // will fail with -EEXISTS
+       ldout(cct, 20) << __func__ << ": removing the old parent link" << dendl;
+       r = cls_client::remove_parent(&ictx->md_ctx, ictx->header_oid);
+       if (r < 0) {
+         ldout(cct, 10) << __func__ << ": failed to remove parent link: "
+                        << cpp_strerror(r) << dendl;
+         return r;
+       }
+    }
+    if (snap_info.parent.spec.pool_id != -1) {
+      ldout(cct, 20) << __func__ << ": updating the parent link" << dendl;
+      r = cls_client::set_parent(&ictx->md_ctx, ictx->header_oid,
+                                 snap_info.parent.spec, snap_info.parent.overlap);
+      if (r < 0) {
+        ldout(cct, 10) << __func__ << ": failed to set parent link: "
+                       << cpp_strerror(r) << dendl;
+        return r;
+      }
+    }
+    return 0;
+  }
+
   int rollback_image(ImageCtx *ictx, uint64_t snap_id,
 		     ProgressContext& prog_ctx)
   {
@@ -444,6 +486,17 @@ int validate_pool(IoCtx &io_ctx, CephContext *cct) {
       RWLock::WLocker l(ictx->snap_lock);
       ictx->object_map.rollback(snap_id);
     }
+
+    {
+      RWLock::WLocker snap_locker(ictx->snap_lock);
+      RWLock::WLocker parent_locker(ictx->parent_lock);
+      r = rollback_parent(ictx, snap_id);
+      if (r < 0) {
+          ldout(cct, 10) << __func__ << ": failed to rollback the parent link: "
+                         << cpp_strerror(r) << dendl;
+          return r;
+      }
+    }
     return 0;
   }
 
diff --git a/src/librbd/parent_types.h b/src/librbd/parent_types.h
index 4dcc452..de7e612 100644
--- a/src/librbd/parent_types.h
+++ b/src/librbd/parent_types.h
@@ -14,12 +14,12 @@ namespace librbd {
     parent_spec() : pool_id(-1), snap_id(CEPH_NOSNAP) {}
     parent_spec(uint64_t pool_id, string image_id, snapid_t snap_id) :
       pool_id(pool_id), image_id(image_id), snap_id(snap_id) {}
-    bool operator==(const parent_spec &other) {
+    bool operator==(const parent_spec &other) const {
       return ((this->pool_id == other.pool_id) &&
 	      (this->image_id == other.image_id) &&
 	      (this->snap_id == other.snap_id));
     }
-    bool operator!=(const parent_spec &other) {
+    bool operator!=(const parent_spec &other) const {
       return !(*this == other);
     }
   };
@@ -28,6 +28,12 @@ namespace librbd {
     parent_spec spec;
     uint64_t overlap;
     parent_info() : overlap(0) {}
+    bool operator==(const parent_info &other) const {
+        return (spec == other.spec) && (overlap == other.overlap);
+    }
+    bool operator!=(const parent_info &other) const {
+      return (spec != other.spec) || (overlap != other.overlap);
+    }
   };
 }
 
