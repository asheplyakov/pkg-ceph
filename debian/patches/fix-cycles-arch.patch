Description: Enable high precision clock for PPC + fallback
 This code is only used for benchmarking so warning and
 fallback if architecture does not have support.
Author: James Page <james.page@ubuntu.com>
Forwarded: no

--- a/src/common/Cycles.h
+++ b/src/common/Cycles.h
@@ -72,8 +72,15 @@ class Cycles {
     uint64_t cntvct;
     asm volatile ("isb; mrs %0, cntvct_el0; isb; " : "=r" (cntvct) :: "memory");
     return cntvct;
+#elif defined(__powerpc__) || defined(__powerpc64__)
+    // Based on:
+    // https://github.com/randombit/botan/blob/net.randombit.botan/src/lib/entropy/hres_timer/hres_timer.cpp
+    uint32_t lo = 0, hi = 0;
+    asm volatile("mftbu %0; mftb %1" : "=r" (hi), "=r" (lo));
+    return (((uint64_t)hi << 32) | lo);
 #else
-#error No high-precision counter available for your OS/arch
+#warning No high-precision counter available for your OS/arch
+    return 0;
 #endif
   }
 
--- a/src/common/Cycles.cc
+++ b/src/common/Cycles.cc
@@ -52,6 +52,10 @@ void Cycles::init()
   if (cycles_per_sec != 0)
     return;
 
+  // Skip initialization if rtdsc is not implemented
+  if (rdtsc() == 0)
+    return;
+
   // Compute the frequency of the fine-grained CPU timer: to do this,
   // take parallel time readings using both rdtsc and gettimeofday.
   // After 10ms have elapsed, take the ratio between these readings.
