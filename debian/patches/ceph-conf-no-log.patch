Last-Update: 2014-04-03
Forwarded: not-needed
Origin: upstream, https://github.com/ceph/ceph/commit/880e6ea3fe74dfac7b167adc15e7865787ebc987
Bug-Ceph: http://tracker.ceph.com/issues/7849
Reviewed-by: Josh Durgin <josh.durgin@inktank.com>
Description: ceph-conf: don't create log files

--- a/src/global/global_init.cc
+++ b/src/global/global_init.cc
@@ -55,10 +55,12 @@
     return NULL;
   return str.c_str();
 }
 
-void global_init(std::vector < const char * > *alt_def_args, std::vector < const char* >& args,
-	       uint32_t module_type, code_environment_t code_env, int flags)
+void global_pre_init(std::vector < const char * > *alt_def_args,
+		     std::vector < const char* >& args,
+		     uint32_t module_type, code_environment_t code_env,
+		     int flags)
 {
   // You can only call global_init once.
   assert(!g_ceph_context);
   std::string conf_file_list;
@@ -103,12 +105,19 @@
 
   // Expand metavariables. Invoke configuration observers.
   conf->apply_changes(NULL);
 
-  g_lockdep = cct->_conf->lockdep;
-
   // Now we're ready to complain about config file parse errors
   complain_about_parse_errors(cct, &parse_errors);
+}
+
+void global_init(std::vector < const char * > *alt_def_args,
+		 std::vector < const char* >& args,
+		 uint32_t module_type, code_environment_t code_env, int flags)
+{
+  global_pre_init(alt_def_args, args, module_type, code_env, flags);
+
+  g_lockdep = g_ceph_context->_conf->lockdep;
 
   // signal stuff
   int siglist[] = { SIGPIPE, 0 };
   block_signals(siglist, NULL);
@@ -130,15 +139,15 @@
   }
 
   if (g_lockdep) {
     dout(1) << "lockdep is enabled" << dendl;
-    lockdep_register_ceph_context(cct);
+    lockdep_register_ceph_context(g_ceph_context);
   }
-  register_assert_context(cct);
+  register_assert_context(g_ceph_context);
 
   // call all observers now.  this has the side-effect of configuring
   // and opening the log file immediately.
-  conf->call_all_observers();
+  g_conf->call_all_observers();
 
   if (code_env == CODE_ENVIRONMENT_DAEMON && !(flags & CINIT_FLAG_NO_DAEMON_ACTIONS))
     output_ceph_version();
 }
--- a/src/global/global_init.h
+++ b/src/global/global_init.h
@@ -29,10 +29,18 @@
  * global_init is the first initialization function that
  * daemons and utility programs need to call. It takes care of a lot of
  * initialization, including setting up g_ceph_context.
  */
-void global_init(std::vector < const char * > *alt_def_args, std::vector < const char* >& args,
-	       uint32_t module_type, code_environment_t code_env, int flags);
+void global_init(std::vector < const char * > *alt_def_args,
+		 std::vector < const char* >& args,
+		 uint32_t module_type, code_environment_t code_env, int flags);
+
+// just the first half; enough to get config parsed but doesn't start up the
+// cct or log.
+void global_pre_init(std::vector < const char * > *alt_def_args,
+		     std::vector < const char* >& args,
+		     uint32_t module_type, code_environment_t code_env,
+		     int flags);
 
 /*
  * perform all of the steps that global_init_daemonize performs just prior
  * to actually forking (via daemon(3)).  return 0 if we are going to proceed
--- a/src/tools/ceph_conf.cc
+++ b/src/tools/ceph_conf.cc
@@ -157,10 +157,10 @@
   argv_to_vec(argc, argv, args);
   env_to_vec(args);
   vector<const char*> orig_args = args;
 
-  global_init(NULL, args, CEPH_ENTITY_TYPE_CLIENT, CODE_ENVIRONMENT_DAEMON,
-	      CINIT_FLAG_NO_DAEMON_ACTIONS);
+  global_pre_init(NULL, args, CEPH_ENTITY_TYPE_CLIENT, CODE_ENVIRONMENT_DAEMON,
+		  CINIT_FLAG_NO_DAEMON_ACTIONS);
 
   // do not common_init_finish(); do not start threads; do not do any of thing
   // wonky things the daemon whose conf we are examining would do (like initialize
   // the admin socket).
