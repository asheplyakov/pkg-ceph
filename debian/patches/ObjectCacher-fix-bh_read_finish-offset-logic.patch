From: Greg Farnum <gfarnum@redhat.com>
Date: Mon, 23 May 2016 15:14:21 -0700
Subject: ObjectCacher: fix bh_read_finish offset logic

If we have an incoming read split across multiple BufferHeads, we want to
line up the BufferHead's bl with the incoming OSDOp's bl at the right offset. We
were erroneously using this nonsense calculation (always equal to zero!) when
a much simpler comparison of the BufferHead's logical object offset to the
incoming OSDOp's logical offset will do the trick nicely.

Fixes: http://tracker.ceph.com/issues/16002

Signed-off-by: Greg Farnum <gfarnum@redhat.com>
(cherry picked from commit 9ec6e7f608608088d51e449c9d375844631dcdde)
---
 src/osdc/ObjectCacher.cc | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/osdc/ObjectCacher.cc b/src/osdc/ObjectCacher.cc
index b2c2572..cad168c 100644
--- a/src/osdc/ObjectCacher.cc
+++ b/src/osdc/ObjectCacher.cc
@@ -787,7 +787,6 @@ void ObjectCacher::bh_read_finish(int64_t poolid, sobject_t oid, ceph_tid_t tid,
       if (bh->error < 0)
 	err = bh->error;
 
-      loff_t oldpos = opos;
       opos = bh->end();
 
       if (r == -ENOENT) {
@@ -807,7 +806,7 @@ void ObjectCacher::bh_read_finish(int64_t poolid, sobject_t oid, ceph_tid_t tid,
 	mark_error(bh);
       } else {
 	bh->bl.substr_of(bl,
-			 oldpos-bh->start(),
+			 bh->start() - start,
 			 bh->length());
 	mark_clean(bh);
       }
